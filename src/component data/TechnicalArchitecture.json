{
  "title": "Technical Architecture Documentation",
  "description": "Comprehensive technical documentation of Clipposaurus architecture, systems, and implementation details",
  "overview": {
    "title": "System Overview",
    "description": "Clipposaurus is a modern, serverless web application built with Next.js, designed for secure, temporary file and content sharing",
    "architecture": "Serverless JAMstack architecture with distributed storage",
    "designPrinciples": [
      "Security by design with end-to-end encryption",
      "Serverless and scalable infrastructure",
      "Privacy-first with minimal data collection",
      "Redundant storage across multiple providers",
      "Progressive web app capabilities",
      "Mobile-first responsive design"
    ]
  },
  "technicalStack": {
    "title": "Technology Stack",
    "frontend": {
      "title": "Frontend Technologies",
      "framework": {
        "name": "Next.js 16.0.0",
        "description": "React-based full-stack framework with App Router",
        "features": [
          "Server-side rendering (SSR)",
          "Static site generation (SSG)",
          "API routes for backend functionality",
          "Automatic code splitting",
          "Built-in performance optimizations"
        ]
      },
      "uiLibrary": {
        "name": "React 18",
        "description": "Modern React with concurrent features",
        "features": [
          "Functional components with hooks",
          "Concurrent rendering",
          "Automatic batching",
          "Suspense for data fetching"
        ]
      },
      "styling": {
        "framework": "Tailwind CSS",
        "description": "Utility-first CSS framework",
        "components": "shadcn/ui + Radix UI primitives",
        "features": [
          "Responsive design utilities",
          "Dark/light theme support",
          "Component composition",
          "Accessible UI components"
        ]
      },
      "stateManagement": {
        "approach": "React Context + Custom Hooks",
        "description": "Lightweight state management without external libraries",
        "contexts": [
          "CreateDropContext - Drop creation state",
          "OpenDropContext - Content retrieval state",
          "ComponentDataContext - UI data management",
          "HeroContext - Landing page state"
        ]
      },
      "typeScript": {
        "version": "TypeScript 5+",
        "description": "Static type checking for improved developer experience",
        "benefits": [
          "Compile-time error detection",
          "Better IDE support and autocomplete",
          "Improved code documentation",
          "Safer refactoring"
        ]
      }
    },
    "backend": {
      "title": "Backend Technologies",
      "runtime": {
        "platform": "Vercel Edge Runtime / Node.js",
        "description": "Serverless functions for API endpoints"
      },
      "database": {
        "primary": "Upstash Redis",
        "description": "Serverless Redis for temporary data storage",
        "features": [
          "Automatic TTL (Time To Live) for content expiration",
          "REST API for serverless compatibility",
          "Global distribution",
          "High availability and durability"
        ],
        "dataTypes": [
          "Encrypted content storage",
          "Access code to content mapping",
          "Rate limiting counters",
          "Session metadata"
        ]
      },
      "storage": {
        "architecture": "Multi-provider redundant storage",
        "providers": [
          {
            "name": "Cloudflare R2",
            "type": "S3-compatible object storage",
            "benefits": ["Global CDN", "No egress fees", "High performance"]
          },
          {
            "name": "Backblaze B2",
            "type": "S3-compatible cloud storage",
            "benefits": ["Cost-effective", "Reliable", "Simple API"]
          },
          {
            "name": "Storj",
            "type": "Decentralized storage network",
            "benefits": ["Distributed", "Secure", "Privacy-focused"]
          }
        ],
        "strategy": "Automatic failover between providers based on availability and quota"
      }
    },
    "security": {
      "title": "Security Technologies",
      "encryption": {
        "algorithm": "AES-256-GCM",
        "library": "Node.js crypto module",
        "implementation": "End-to-end encryption with unique session keys"
      },
      "transport": {
        "protocol": "HTTPS/TLS 1.3",
        "headers": [
          "Strict-Transport-Security (HSTS)",
          "Content-Security-Policy (CSP)",
          "X-Frame-Options",
          "X-Content-Type-Options"
        ]
      },
      "rateLimiting": {
        "implementation": "Redis-based rate limiting per IP address",
        "limits": "100 requests per hour per IP"
      },
      "botProtection": {
        "service": "Google reCAPTCHA v3",
        "implementation": "Score-based bot detection on sensitive operations"
      }
    }
  },
  "systemArchitecture": {
    "title": "System Architecture",
    "components": [
      {
        "component": "Frontend Application",
        "description": "React-based SPA with SSR capabilities",
        "responsibilities": [
          "User interface rendering",
          "Client-side state management",
          "File processing and validation",
          "Content encryption/decryption",
          "Progressive web app features"
        ],
        "deployment": "Vercel Edge Network (CDN)"
      },
      {
        "component": "API Layer",
        "description": "Next.js API routes handling business logic",
        "endpoints": [
          "/api/create-drop - Content creation and storage",
          "/api/open-drop - Content retrieval and decryption",
          "/api/delete-drop - Manual content deletion",
          "/api/proxy-download - File download proxy",
          "/api/component-data - Dynamic UI data"
        ],
        "deployment": "Vercel Serverless Functions"
      },
      {
        "component": "Storage Layer",
        "description": "Distributed file storage across multiple providers",
        "features": [
          "Automatic provider selection based on quotas",
          "Encrypted file storage with metadata",
          "Redundant storage for reliability",
          "Global distribution for performance"
        ]
      },
      {
        "component": "Cache Layer",
        "description": "Redis-based temporary data storage",
        "purpose": [
          "Access code to content mapping",
          "Rate limiting enforcement",
          "Session state management",
          "Automatic content expiration"
        ]
      }
    ],
    "dataFlow": {
      "title": "Data Flow Architecture",
      "upload": [
        {
          "step": 1,
          "component": "Frontend",
          "action": "User uploads content (files/text/code)"
        },
        {
          "step": 2,
          "component": "Client",
          "action": "Content validation and preprocessing"
        },
        {
          "step": 3,
          "component": "API",
          "action": "Content encryption and storage provider selection"
        },
        {
          "step": 4,
          "component": "Storage",
          "action": "Encrypted content stored across providers"
        },
        {
          "step": 5,
          "component": "Redis",
          "action": "Access code mapping created with TTL"
        },
        {
          "step": 6,
          "component": "Response",
          "action": "Magic words returned to user"
        }
      ],
      "retrieval": [
        {
          "step": 1,
          "component": "Frontend",
          "action": "User enters magic words (access code)"
        },
        {
          "step": 2,
          "component": "API",
          "action": "Access code validated against Redis"
        },
        {
          "step": 3,
          "component": "Storage",
          "action": "Encrypted content retrieved from storage"
        },
        {
          "step": 4,
          "component": "API",
          "action": "Content decrypted server-side"
        },
        {
          "step": 5,
          "component": "Frontend",
          "action": "Decrypted content displayed to user"
        }
      ]
    }
  },
  "apiArchitecture": {
    "title": "API Architecture",
    "design": "RESTful API with JSON payloads",
    "structure": {
      "requestFlow": [
        "Request validation and sanitization",
        "Rate limiting check",
        "reCAPTCHA verification (if required)",
        "Business logic execution",
        "Response formatting and return"
      ],
      "errorHandling": [
        "Standardized error response format",
        "Appropriate HTTP status codes",
        "Client-friendly error messages",
        "Server-side error logging"
      ]
    },
    "middleware": [
      {
        "name": "Rate Limiting Middleware",
        "purpose": "Prevent API abuse",
        "implementation": "Redis-based sliding window"
      },
      {
        "name": "Validation Middleware",
        "purpose": "Request validation",
        "implementation": "Zod schema validation"
      },
      {
        "name": "Error Handling Middleware",
        "purpose": "Consistent error responses",
        "implementation": "Global error handler"
      }
    ]
  },
  "dataModels": {
    "title": "Data Models & Schemas",
    "models": [
      {
        "name": "StoredContent",
        "description": "Main content structure stored in Redis",
        "schema": {
          "textContent": "string (optional)",
          "codeContent": "string (optional)",
          "codeLanguage": "string (optional)",
          "files": "array of FileReference (optional)",
          "createdAt": "ISO timestamp",
          "expiresAt": "ISO timestamp"
        },
        "encryption": "Entire object encrypted before Redis storage"
      },
      {
        "name": "FileReference",
        "description": "Reference to uploaded files in storage",
        "schema": {
          "id": "unique file identifier",
          "name": "original filename",
          "url": "public storage URL",
          "size": "file size in bytes",
          "lastModified": "timestamp",
          "provider": "storage provider name"
        }
      },
      {
        "name": "FileToUpload",
        "description": "File data during upload process",
        "schema": {
          "id": "unique identifier",
          "name": "filename with extension",
          "content": "base64 encoded file content",
          "size": "file size in bytes",
          "lastModified": "timestamp"
        }
      },
      {
        "name": "UploadResult",
        "description": "Storage operation result",
        "schema": {
          "success": "boolean",
          "url": "public file URL (if successful)",
          "error": "error message (if failed)",
          "provider": "storage provider used"
        }
      }
    ]
  },
  "storageArchitecture": {
    "title": "Storage Architecture",
    "strategy": "Multi-provider redundant storage with automatic failover",
    "implementation": {
      "fileStorage": {
        "encryption": "AES-256-GCM encryption before upload",
        "format": "Encrypted JSON objects containing original file data",
        "naming": "Timestamp + random suffix + file ID + extension",
        "metadata": "Original filename, content type, timestamps stored as object metadata"
      },
      "providerSelection": {
        "algorithm": "First available provider with quota < 90%",
        "fallback": "Try next provider if current fails",
        "monitoring": "Real-time quota checking via S3 ListObjects"
      },
      "quotaManagement": {
        "limits": {
          "cloudflareR2": "10GB free tier",
          "backblazeB2": "10GB free tier",
          "storj": "25GB free tier"
        },
        "monitoring": "Automated quota checking before each upload",
        "alerting": "Skip provider when > 90% quota used"
      }
    },
    "s3Compatibility": {
      "description": "All storage providers implement S3-compatible APIs",
      "operations": [
        "PutObject for file uploads",
        "GetObject for file retrieval",
        "ListObjectsV2 for quota checking",
        "DeleteObject for cleanup (planned)"
      ],
      "authentication": "Access keys and secrets for each provider"
    }
  },
  "securityArchitecture": {
    "title": "Security Architecture",
    "layers": [
      {
        "layer": "Transport Security",
        "components": [
          "TLS 1.3 encryption for all communications",
          "Certificate pinning (planned)",
          "HSTS headers for HTTPS enforcement",
          "Secure cookie configuration"
        ]
      },
      {
        "layer": "Application Security",
        "components": [
          "Content Security Policy (CSP) headers",
          "Input validation and sanitization",
          "XSS protection headers",
          "CSRF protection via same-origin policy"
        ]
      },
      {
        "layer": "Data Security",
        "components": [
          "End-to-end encryption with AES-256-GCM",
          "Unique encryption keys per session",
          "Secure key derivation with PBKDF2",
          "No plaintext storage of sensitive data"
        ]
      },
      {
        "layer": "Access Control",
        "components": [
          "Cryptographically secure access codes",
          "Time-based access expiration",
          "Rate limiting per IP address",
          "reCAPTCHA bot protection"
        ]
      }
    ],
    "threatMitigation": [
      {
        "threat": "Data Interception",
        "mitigation": "End-to-end encryption + TLS"
      },
      {
        "threat": "Unauthorized Access",
        "mitigation": "Cryptographically secure access codes"
      },
      {
        "threat": "Data Persistence",
        "mitigation": "Automatic expiration and deletion"
      },
      {
        "threat": "DDoS Attacks",
        "mitigation": "Cloudflare protection + rate limiting"
      },
      {
        "threat": "Bot Abuse",
        "mitigation": "reCAPTCHA + behavioral analysis"
      }
    ]
  },
  "performanceArchitecture": {
    "title": "Performance Architecture",
    "optimization": [
      {
        "area": "Frontend Performance",
        "techniques": [
          "Next.js automatic code splitting",
          "Image optimization with next/image",
          "Lazy loading of non-critical components",
          "Service worker for offline functionality",
          "Compression with gzip/brotli"
        ]
      },
      {
        "area": "API Performance",
        "techniques": [
          "Serverless functions for auto-scaling",
          "Edge computing for reduced latency",
          "Efficient Redis operations",
          "Streaming uploads for large files",
          "Connection pooling and reuse"
        ]
      },
      {
        "area": "Storage Performance",
        "techniques": [
          "Global CDN distribution",
          "Parallel uploads to multiple providers",
          "Optimized file formats and compression",
          "Direct storage provider access where possible",
          "Intelligent provider selection"
        ]
      }
    ],
    "monitoring": [
      "Vercel Analytics for real-time performance metrics",
      "Speed Insights for Core Web Vitals tracking",
      "Custom metrics for API response times",
      "Storage provider performance monitoring"
    ]
  },
  "scalabilityConsiderations": {
    "title": "Scalability Architecture",
    "horizontalScaling": [
      "Serverless functions automatically scale with demand",
      "Redis cluster for high-availability caching",
      "Multiple storage providers for distributed load",
      "CDN edge locations for global performance"
    ],
    "bottlenecks": [
      {
        "component": "Storage Providers",
        "limitation": "Free tier quota limits",
        "mitigation": "Multiple providers + quota monitoring + premium plans"
      },
      {
        "component": "Redis",
        "limitation": "Connection and memory limits",
        "mitigation": "Upstash serverless Redis + connection pooling"
      },
      {
        "component": "File Processing",
        "limitation": "Large file upload/download times",
        "mitigation": "Streaming uploads + compression + parallel processing"
      }
    ],
    "futureEnhancements": [
      "Dedicated storage accounts for higher quotas",
      "Multiple Redis instances for geographic distribution",
      "Advanced caching layers",
      "Optimized file processing pipeline"
    ]
  },
  "deploymentArchitecture": {
    "title": "Deployment Architecture",
    "cicd": {
      "platform": "Vercel",
      "workflow": [
        "Git push triggers automatic deployment",
        "Build process runs Next.js optimizations",
        "Environment variables injected securely",
        "Preview deployments for pull requests",
        "Production deployment on main branch merge"
      ]
    },
    "environments": [
      {
        "name": "Development",
        "url": "localhost:3000",
        "features": ["Hot reloading", "Debug mode", "Local Redis/storage"]
      },
      {
        "name": "Preview",
        "url": "preview-deployments.vercel.app",
        "features": ["PR previews", "Testing environment", "Staging data"]
      },
      {
        "name": "Production",
        "url": "clipposaurus.com",
        "features": ["Optimized build", "CDN distribution", "Full monitoring"]
      }
    ],
    "infrastructure": {
      "hosting": "Vercel Edge Network",
      "functions": "Serverless with automatic scaling",
      "storage": "Distributed across Cloudflare R2, Backblaze B2, Storj",
      "database": "Upstash Redis (serverless)",
      "monitoring": "Vercel Analytics + Speed Insights"
    }
  },
  "codeOrganization": {
    "title": "Code Organization",
    "structure": {
      "appDirectory": {
        "path": "/src/app",
        "description": "Next.js App Router pages and layouts",
        "structure": [
          "page.tsx - Route components",
          "layout.tsx - Layout wrappers",
          "loading.tsx - Loading states",
          "error.tsx - Error boundaries",
          "api/ - API route handlers"
        ]
      },
      "components": {
        "path": "/src/components",
        "structure": [
          "ui/ - Reusable UI primitives (shadcn/ui)",
          "custom/ - Application-specific components",
          "animate-ui/ - Animation components",
          "skeleton/ - Loading skeleton components"
        ],
        "patterns": [
          "Compound component patterns",
          "Render prop patterns",
          "Custom hook composition",
          "Prop forwarding with forwardRef"
        ]
      },
      "hooks": {
        "path": "/src/hooks",
        "description": "Custom React hooks for reusable logic",
        "examples": [
          "useFileProcessor - File upload/processing logic",
          "useCreateDropManager - Drop creation state",
          "useOpenDropManager - Drop retrieval state",
          "useToast - Toast notification management"
        ]
      },
      "services": {
        "path": "/src/services",
        "description": "Business logic and external service integrations",
        "modules": [
          "fileStorage.ts - Storage provider management",
          "fileDecryption.ts - File decryption service",
          "getWelcomePage.ts - Content management service"
        ]
      },
      "lib": {
        "path": "/src/lib",
        "description": "Utility libraries and configurations",
        "modules": [
          "encryption.ts - Cryptographic operations",
          "utils.ts - General utilities",
          "redis.ts - Database client",
          "env.ts - Environment configuration"
        ]
      },
      "types": {
        "path": "/src/types",
        "description": "TypeScript type definitions",
        "organization": [
          "index.d.ts - Main application types",
          "storage.d.ts - Storage-related types",
          "encryption.d.ts - Encryption types"
        ]
      }
    },
    "patterns": {
      "designPatterns": [
        "Factory pattern for storage providers",
        "Strategy pattern for encryption algorithms",
        "Observer pattern for state management",
        "Command pattern for API operations"
      ],
      "codeQuality": [
        "ESLint for code quality enforcement",
        "Prettier for consistent formatting",
        "TypeScript for type safety",
        "JSDoc comments for documentation"
      ]
    }
  },
  "testingStrategy": {
    "title": "Testing Strategy (Planned)",
    "levels": [
      {
        "level": "Unit Testing",
        "scope": "Individual functions and components",
        "tools": "Jest + React Testing Library",
        "coverage": "Utility functions, hooks, components"
      },
      {
        "level": "Integration Testing",
        "scope": "API endpoints and service interactions",
        "tools": "Jest + Supertest",
        "coverage": "API routes, storage operations, encryption"
      },
      {
        "level": "End-to-End Testing",
        "scope": "Complete user workflows",
        "tools": "Playwright or Cypress",
        "coverage": "Upload/download flows, content sharing"
      }
    ],
    "testData": [
      "Mock storage providers for testing",
      "Encrypted test content samples",
      "Rate limiting test scenarios",
      "Error condition simulations"
    ]
  }
}
